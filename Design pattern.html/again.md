## 面向对象设计中常见的设计原则
### 推荐博客(笔记内容从该博客转载)：https://blog.csdn.net/qq_34760445/article/details/82931002
### 单一职责原则
* 永远不要让一个类存在多个改变的理由。
* 单一职责原则原则的核心含意是：只能让一个类/接口/方法有且仅有一个职责。

#### 为什么一个类不能有多于一个以上的职责？
* 如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，而这种变化将影响到该类不同职责的使用者（不同用户）：
* 一方面，如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。
* 另一方面，某个用户由于某个原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。这违反了设计的开闭原则，也不是我们所期望的。

#### 职责的划分
* 既然一个类不能有多个职责，那么怎么划分职责呢？
* Robert.C Martin给出了一个著名的定义：所谓一个类的一个职责是指引起该类变化的一个原因。
* 如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。
### 开闭原则
#### 开闭原则定义 ：
* 一个软件实体应当对扩展开放，对修改关闭。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。

#### 开闭原则分析：
* 开闭原则由Bertrand Meyer于1988年提出，它是面向对象设计中最重要的原则之一。
* 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。  
* 抽象化是开闭原则的关键。
* 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation,EVP)要求找到系统的可变因素并将其封装起来。

### 里氏替换原则
#### 概念理解
* 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。
* 里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。
#### 里式替换原则的优点
* 约束继承泛滥，是开闭原则的一种体现。
* 加强程序的健壮性，同时变更时也可以做到非常好地提高程序的维护性、扩展性。降低需求变更时引入的风险。

### 依赖倒置原则
#### 概念理解
* 依赖：在程序设计中，如果一个模块a使用/调用了另一个模块b，我们称模块a依赖模块b。
* 高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。
* 依赖倒置（Dependency Inversion）：面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。因为传统的结构化程序设计中，高层模块总是依赖于低层模块。

#### 问题的提出：
* 系统很难改变，因为每个改变都会影响其他很多部分。
* 当你对某地方做一修改，系统的看似无关的其他部分都不工作了。
* 系统很难被另外一个应用重用，因为很难将要重用的部分从系统中分离开来。
* 导致“Bad Design”的很大原因是“高层模块”过分依赖“低层模块”。
* 一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。

#### 问题的解决：
* 在高层模块与低层模块之间，引入一个抽象接口层。
* 抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。
* 这样，高层模块不直接依赖低层模块，而是依赖抽象接口层。抽象接口也不依赖低层模块的实现细节，而是低层模块依赖（继承或实现）抽象接口。
* 类与类之间都通过抽象接口层来建立关系。

### 接口隔离原则
#### 概念理解
* 接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。
* 接口的依赖（继承）原则：如果一个接口a继承另一个接口b，则接口a相当于继承了接口b的方法，那么继承了接口b后的接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。

#### 使用原则
* 一个类对一个类的依赖应该建立在最小的接口上
* 建立单一接口，不要建立庞大臃肿的接口
* 尽量细化接口，接口中的方法尽量少

### 最少知识原则（迪米特法则）
* 迪米特原则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
* 迪米特原则不希望类直接建立直接的接触。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特原则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系，这在一定程度上增加了系统的复杂度。

### 少用继承多用组合（合成复用）
#### 概念理解
* 即在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。就是说要尽量的使用合成和聚合，而不是继承关系达到复用的目的。

#### 什么时候才应该使用继承
* 派生类是基类的一个特殊种类，而不是基类的一个角色，也就是区分"Has-A"和"Is-A"。只有"Is-A"关系才符合继承关系，"Has-A"关系应当用聚合来描述。
* 永远不会出现需要将派生类换成另外一个类的派生类的情况。如果不能肯定将来是否会变成另外一个派生类的话，就不要使用继承。
* 派生类具有扩展基类的责任，而不是具有置换掉（override）或注销掉（Nullify）基类的责任。如果一个派生类需要大量的置换掉基类的行为，那么这个类就不应该是这个基类的派生类。
* 只有在分类学角度上有意义时，才可以使用继承。
